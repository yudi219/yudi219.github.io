<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Class"><meta name="author" content="John Doe"><meta name="keywords" content=""><meta name="copyright" content="copyright.liscense_type"><title>Class</title><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://cdn.bootcss.com/respond/1.4.2/respond.min.js"></script><![endif]--><link rel="icon" href="/compass/imgs/favicon.ico"><link rel="stylesheet" href="/compass/stylesheets/font-awesome.min.css"><script>var algoliaConfig = {"on":false}</script><link rel="stylesheet" href="/compass/stylesheets/screen.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="body-inner-wrapper"><header id="page-header"><nav id="nav"><div id="site-name">Hexo</div><i class="fa fa-bars fa-2x" id="nav-icon" aria-hidden="true"></i><div id="nav-expanded"><a class="nav-word-item" href="/">Home</a><a class="nav-word-item" href="/archives">Archives</a><a class="nav-word-item" href="/tags">Tags</a><a class="nav-word-item" href="/categories">Catogories</a></div><div id="nav-list"><ul><li><a class="nav-list-item" href="/">Home</a></li><li><a class="nav-list-item" href="/archives">Archives</a></li><li><a class="nav-list-item" href="/tags">Tags</a></li><li><a class="nav-list-item" href="/categories">Catogories</a></li></ul></div></nav><div id="banner-wrapper"><div id="banner-pagetype-dependent-info"><h1 id="post-title">Class</h1><span id="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-28</span><span id="word-count">The total word count - 1830</span><span id="time-count">Estimated time of reading - 7 mins</span></div></div><a title="Back to Top"><i class="fa fa-arrow-up" id="to-Top" aria-hidden="true"></i></a><a title="Click to Toggle off"><i class="fa fa-toggle-on" id="toggle-on-Toc" aria-hidden="true"></i></a><a title="Click to Toggle on"><i class="fa fa-toggle-off" id="toggle-off-Toc" aria-hidden="true"></i></a></header><aside id="toc-column"><div id="toc-column-inner-wrapper"><div id="post-toc"></div></div></aside><main id="main-content-column"><div id="main-content-wrapper"><div id="post-full-content"><p>传统的javascript中只有对象，没有类的概念。它是基于原型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。这样的写法相对于其它传统面向对象语言来讲，很有一种独树一帜的感脚！非常容易让人困惑！<br>如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。构造函数示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数名和实例化构造名相同且大写（非强制，但这么写有助于区分构造函数和普通函数）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我的名字叫&quot;</span> + <span class="built_in">this</span>.name+<span class="string">&quot;今年&quot;</span>+<span class="built_in">this</span>.age+<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);<span class="comment">//通过构造函数创建对象，必须使用new 运算符</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.say());<span class="comment">//我的名字叫laotie今年88岁了</span></span><br></pre></td></tr></table></figure>
<p><strong>构造函数生成实例的执行过程：</strong><br>1.当使用了构造函数，并且new 构造函数(),后台会隐式执行new Object()创建对象;<br>2.将构造函数的作用域给新对象，（即new Object()创建出的对象），而函数体内的this就代表new Object()出来的对象。<br>3.执行构造函数的代码。<br>4.返回新对象（后台直接返回）;</p>
<blockquote>
<p>ES6引入了 <code>Class</code>（类）这个概念，作为对象的模板。通过class关键字，可以定义类。该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言。<br>但是JS 中并没有一个真正的 <code>class</code> 原始类型， <code>class</code> 仅仅只是对原型对象运用语法糖。所以，只有理解如何使用原型对象实现类和类继承，才能真正地用好 <code>class</code>。<br>如果将之前的代码改为ES6的写法就会是这个样子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;<span class="comment">//定义了一个名字为Person的类</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;<span class="comment">//constructor是一个构造方法，用来接收参数</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">//this代表的是实例对象</span></span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;<span class="comment">//这是一个类的方法，注意千万不要加上function</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的名字叫&quot;</span> + <span class="built_in">this</span>.name+<span class="string">&quot;今年&quot;</span>+<span class="built_in">this</span>.age+<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.say());<span class="comment">//我的名字叫laotie今年88岁了</span></span><br></pre></td></tr></table></figure>
<p><strong>注意项</strong><br>1.在类中声明方法的时候，千万不要给该方法加上function关键字<br>2.方法之间不要用逗号分隔，否则会报错</p>
<p>由下面代码可以看出类实质上就是一个函数。类自身指向的就是构造函数。所以可以认为ES6中的类其实就是构造函数的另外一种写法！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(Person===Person.prototype.constructor);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>以下代码说明构造函数的prototype属性，在ES6的类中依然存在着。<br>console.log(Person.prototype);//输出的结果是一个对象<br>实际上类的所有方法都定义在类的prototype属性上。代码证明下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//定义与类中相同名字的方法。成功实现了覆盖！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是来证明的，你叫&quot;</span> + <span class="built_in">this</span>.name+<span class="string">&quot;今年&quot;</span>+<span class="built_in">this</span>.age+<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.say());<span class="comment">//我是来证明的，你叫laotie今年88岁了</span></span><br></pre></td></tr></table></figure>
<p>当然也可以通过prototype属性对类添加方法。如下：<br>Person.prototype.addFn=function(){<br>    return “我是通过prototype新增加的方法,名字叫addFn”;<br>}<br>var obj=new Person(“laotie”,88);<br>console.log(obj.addFn());//我是通过prototype新增加的方法,名字叫addFn<br>还可以通过Object.assign方法来为对象动态增加方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Person.prototype,&#123;</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName());<span class="comment">//laotie</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getAge());<span class="comment">//88</span></span><br></pre></td></tr></table></figure>
<p>constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;啦啦啦，今天天气好晴朗&quot;</span>);<span class="comment">//当实例化对象时该行代码会执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Box();</span><br></pre></td></tr></table></figure>
<p>constructor方法如果没有显式定义，会隐式生成一个constructor方法。所以即使你没有添加构造函数，构造函数也是存在的。constructor方法默认返回实例对象this，但是也可以指定constructor方法返回一个全新的对象，让返回的实例对象不是该类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.xixi=<span class="string">&quot;我是一只小小小小鸟！哦&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Desk();<span class="comment">// 这里没有用this哦，直接返回一个全新的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(obj.xixi);<span class="comment">//我是一只小小小小鸟！哦</span></span><br></pre></td></tr></table></figure>
<p>constructor中定义的属性可以称为实例属性（即定义在this对象上），constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)。hasOwnProperty()函数用于判断属性是否是实例属性。其结果是一个布尔值， true说明是实例属性，false说明不是实例属性。in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例中还是原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num1 = num1;</span><br><span class="line">        <span class="built_in">this</span>.num2=num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box=<span class="keyword">new</span> Box(<span class="number">12</span>,<span class="number">88</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box.hasOwnProperty(<span class="string">&quot;num1&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(box.hasOwnProperty(<span class="string">&quot;num2&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(box.hasOwnProperty(<span class="string">&quot;sum&quot;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;num1&quot;</span> <span class="keyword">in</span> box);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;num2&quot;</span> <span class="keyword">in</span> box);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sum&quot;</span> <span class="keyword">in</span> box);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;say&quot;</span> <span class="keyword">in</span> box);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>类的所有实例共享一个原型对象，它们的原型都是Person.prototype，所以proto属性是相等的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num1 = num1;</span><br><span class="line">        <span class="built_in">this</span>.num2=num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//box1与box2都是Box的实例。它们的__proto__都指向Box的prototype</span></span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box(<span class="number">12</span>,<span class="number">88</span>);</span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box(<span class="number">40</span>,<span class="number">60</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box1.__proto__===box2.__proto__);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由此，也可以通过proto来为类增加方法。使用实例的proto属性改写原型，会改变Class的原始定义，影响到所有实例，所以不推荐使用！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num1 = num1;</span><br><span class="line">        <span class="built_in">this</span>.num2=num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box(<span class="number">12</span>,<span class="number">88</span>);</span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box(<span class="number">40</span>,<span class="number">60</span>);</span><br><span class="line">box1.__proto__.sub=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num2-<span class="built_in">this</span>.num1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(box1.sub());<span class="comment">//76</span></span><br><span class="line"><span class="built_in">console</span>.log(box2.sub());<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>class不存在变量提升，所以需要先定义再使用。因为ES6不会把类的声明提升到代码头部，但是ES5就不一样,ES5存在变量提升,可以先使用，然后再定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5可以先使用再定义,存在变量提升</span></span><br><span class="line"><span class="keyword">new</span> A();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6不能先使用再定义,不存在变量提升 会报错</span></span><br><span class="line"><span class="keyword">new</span> B();<span class="comment">//B is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></div></main><div id="pagination-wrapper"><a id="page-prev" href="/2020/12/29/vue%E5%8E%9F%E7%90%86%E4%B9%8B-%E7%A5%9E%E5%A5%87%E7%9A%84Object-defineProperty/"><i class="fa fa-chevron-left"></i> vue原理之-神奇的Object.defineProperty</a><a id="page-next" href="/2020/12/25/hooks/">hooks <i class="fa fa-chevron-right"></i></a></div><footer id="page-footer"><div id="footer-wrapper"><div id="blog-meta">&copy;2017-2020 By John Doe | Theme - <a id='theme-name' target="_blank" rel="noopener" href="https://github.com/huan555/lemon-lime"> Lemon-Lime</a> | Power By <a id='theme-powered-by' href=http://hexo.io> Hexo</a></div><div id="viewed-record"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span></span></div><div id="copyright-wrapper"><i class="fa fa-cc" aria-hidden="true"></i><div id="copyright">Except where otherwise noted, content on this blog is licensed under <a rel="license" href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a>.</div></div><div id="contact-me"><div id="rss"><a href="/atom.xml" type="application/atom+xml" rel="alternate" target="_blank"><i class="fa fa-rss" aria-hidden="true"></i></a></div><span id="github"><a target="_blank" rel="noopener" href="https://github.com/yourUserName"><i class="fa fa-github" aria-hidden="true"></i></a></span></div></div></footer><script src="/compass/js/blog.js"></script></div></body>